using System;
using System.Threading;

namespace PolusSolution3
{
    class Program
    {

        static Timer timer;

        static void f(object obj)
        {

            Console.WriteLine(DateTime.Now + " Запущен");

            Thread.Sleep(6500);

            Console.WriteLine(DateTime.Now + " Остановлен");

        }

        /*
         * 
         * Как видно из примера, каждый экземпляр метода запускается таймером асинхронно.
         * 
         * Проблема 1:  Если метод работает гораздо дольше, чем интервал таймера, то возможны случаи, когда два и более экземпляра потребуют 
         *              доступ к одному ресурсу, что в свою очередь приведет к "падению" приложения.         * 
         * Решение 1:   Нужно синхронизировать доступ к ресурсам с помощью семафора или мьютекса
         * Исправление (в моем понимании): использование ключевого слова lock
         * 
         * 
         * Проблема 2:  Возможно, вычисления должны проходить последовательно, а длительность каждого из них превышает интервал таймера         * 
         * Решение 2:   В таком случае, проще не использовать таймер вовсе :)
         * Исправление (в моем понимании):  Если требуется использование таймера, то возможно, при вызове метода, останавливать таймер и запускать его после выполнения кода
         *                                  Если таймер необязателен, то можно попробовать создать список задач и запускать их последовательно
         * 
         */

        static void Main(string[] args)
        {

            timer = new Timer(f, null, 0, 5 * 1000);

            Console.ReadKey();

        }
    }
}
